1. First to create the structure of the graph in Neo4j:
This first step is just to create an initial schema of the database, you don't need to run this command as it will just create a second graph without the actual
generated data. So skip this step, only run if you want to visualize the A1 schema in neo4j.

CREATE (:Keyword {name: "string"})<-[:HAS_KEYWORD]-(n6:Paper {title: "string", abstract: "string", doi: "string"})<-[:ASSIGNED_REVIEWER]-(:Author {name: "string"})-[:WROTE {corresponding: "bool"}]->(n2:Paper {title: "string", abstract: "string", doi: "string"})-[:PUBLISHED_IN {date_accepted: "date"}]->(n4:ProceedingEdition {number: "integer", start_date: "date", end_date: "date"})-[:HELD_IN]->(:Venue {venue_name: "string"}),
(:Keyword {name: "string"})<-[:HAS_KEYWORD]-(n2)-[:CITES]->(n6)-[:HAS_KEYWORD]->(n8:Keyword {name: "string"}),
(n2)-[:HAS_KEYWORD]->(n8),
(:Journal {journal_name: "string"})-[:HAS_VOLUME]->(:JournalVolume {volume: "int", year: "int", issue: "int"})<-[:PUBLISHED_IN {accepted_date: "date", pages: "string"}]-(n6),
(n4)-[:_RELATED]->({type: "string", name: "string"})

2. Graph visualization: 
MATCH (n)-[r]->(m) RETURN n, r, m

3. Create the necessary constraints to ensure the needed values are unique
CREATE CONSTRAINT author_id_unique IF NOT EXISTS FOR (a:Author) REQUIRE a.id IS UNIQUE;
CREATE CONSTRAINT paper_id_unique IF NOT EXISTS FOR (p:Paper) REQUIRE p.id IS UNIQUE;
CREATE CONSTRAINT keyword_id_unique IF NOT EXISTS FOR (k:Keyword) REQUIRE k.id IS UNIQUE;
CREATE CONSTRAINT proceeding_id_unique IF NOT EXISTS FOR (pe:ProceedingEdition) REQUIRE pe.id IS UNIQUE;
CREATE CONSTRAINT venue_id_unique IF NOT EXISTS FOR (v:Venue) REQUIRE v.id IS UNIQUE;
CREATE CONSTRAINT journal_id_unique IF NOT EXISTS FOR (j:Journal) REQUIRE j.id IS UNIQUE;
CREATE CONSTRAINT journalvolume_id_unique IF NOT EXISTS FOR (v:JournalVolume) REQUIRE v.id IS UNIQUE;

4. Load the file with the data csv in the import Neo4j folder. 
To open this folder go to your local database -> ... next to Open button -> open folder -> import

5. Create the entities (Important: the blocks of loading code need to be executed one by one, not all at once in the same cell)
// Authors
LOAD CSV WITH HEADERS FROM 'file:///data_lab1/authors.csv' AS row
CREATE (:Author {id: toInteger(row.id), name: row.name});

// Keywords
LOAD CSV WITH HEADERS FROM 'file:///data_lab1/keywords.csv' AS row
CREATE (:Keyword {id: toInteger(row.id), name: row.name});

// Papers
LOAD CSV WITH HEADERS FROM 'file:///data_lab1/papers.csv' AS row
CREATE (:Paper {id: toInteger(row.id), title: row.title, abstract: row.abstract, doi: row.doi});

// Proceedings (conference editions)
LOAD CSV WITH HEADERS FROM 'file:///data_lab1/proceedings.csv' AS row
CREATE (:ProceedingEdition {id: toInteger(row.id), number: toInteger(row.number), start_date: date(row.start_date), end_date: date(row.end_date)});

// Venues
LOAD CSV WITH HEADERS FROM 'file:///data_lab1/venues.csv' AS row
CREATE (:Venue {id: toInteger(row.id), venue_name: row.venue_name});

// Journals
LOAD CSV WITH HEADERS FROM 'file:///data_lab1/journals.csv' AS row
CREATE (:Journal {id: toInteger(row.id), journal_name: row.journal_name});

// Journal Volumes
LOAD CSV WITH HEADERS FROM 'file:///data_lab1/journal_volumes.csv' AS row
CREATE (:JournalVolume {id: toInteger(row.id), volume: toInteger(row.volume), year: toInteger(row.year), issue: toInteger(row.issue)});

6. Create the relationships 
// CITES relationships (Paper -> Paper)
LOAD CSV WITH HEADERS FROM 'file:///data_lab1/citations.csv' AS row
MATCH (source:Paper {id: toInteger(row.source_paper)}), (target:Paper {id: toInteger(row.target_paper)})
CREATE (source)-[:CITES]->(target);

// WROTE relationships (Author -> Paper)
LOAD CSV WITH HEADERS FROM 'file:///data_lab1/wrote.csv' AS row
MATCH (a:Author {id: toInteger(row.author_id)}), (p:Paper {id: toInteger(row.paper_id)})
CREATE (a)-[:WROTE {corresponding: toBoolean(row.corresponding)}]->(p);

// HAS_KEYWORD relationships (Paper -> Keyword)
LOAD CSV WITH HEADERS FROM 'file:///data_lab1/has_keyword.csv' AS row
MATCH (p:Paper {id: toInteger(row.paper_id)}), (k:Keyword {id: toInteger(row.keyword_id)})
CREATE (p)-[:HAS_KEYWORD]->(k);

// PUBLISHED_IN relationships (Paper -> ProceedingEdition or JournalVolume)
LOAD CSV WITH HEADERS FROM 'file:///data_lab1/published_in.csv' AS row
MATCH (p:Paper {id: toInteger(row.paper_id)})
OPTIONAL MATCH (pe:ProceedingEdition {id: toInteger(row.proceeding_id)})
OPTIONAL MATCH (jv:JournalVolume {id: toInteger(row.journal_volume_id)})
FOREACH (_ IN CASE WHEN pe IS NOT NULL THEN [1] ELSE [] END |
  CREATE (p)-[:PUBLISHED_IN {accepted_date: date(row.date_accepted), pages: row.pages}]->(pe)
)
FOREACH (_ IN CASE WHEN jv IS NOT NULL THEN [1] ELSE [] END |
  CREATE (p)-[:PUBLISHED_IN {accepted_date: date(row.date_accepted), pages: row.pages}]->(jv)
);

// HELD_IN relationships (ProceedingEdition -> Venue)
LOAD CSV WITH HEADERS FROM 'file:///data_lab1/held_in.csv' AS row
MATCH (proceeding:ProceedingEdition {id: toInteger(row.proceeding_id)}), (venue:Venue {id: toInteger(row.venue_id)})
CREATE (proceeding)-[:HELD_IN]->(venue);

// _RELATED relationships (ProceedingEdition -> Virtual node)
LOAD CSV WITH HEADERS FROM 'file:///data_lab1/related.csv' AS row
MATCH (proceeding:ProceedingEdition {id: toInteger(row.proceeding_id)})
CREATE (proceeding)-[:_RELATED]->(:Related {type: row.type, name: row.name});

7. Visualize the final graph: 
MATCH (n)-[r]->(m) 
RETURN n, r, m;